필독 미니 프로젝트 안내
https://www.notion.so/1c0caf5650aa811c988dd83de237658c

백엔드 API 가이드
https://docs.google.com/spreadsheets/d/1qL__Ming4UcAr9EQb5MLC2v21x27RD4-NK3XknnVmuI/edit?gid=0#gid=0

[1단계] 깃리파짓토리 생성, 장고 프로젝트 생성, PostgresDB연결
https://www.notion.so/1-1c2caf5650aa808eb4f5c87fe12964e7
[2단계] ERD 설계와 Model 생성
https://www.notion.so/2-1c2caf5650aa8066a17acaf8d4d70b20
[3단계] 유저 플로우 차트 설계 및 유저 API 구현
https://www.notion.so/3-1c2caf5650aa808fba55d686a2c9e5aa
[4단계] 계좌, 거래 API 구현
https://www.notion.so/4-1c2caf5650aa80cbbb82c2b4b73132c6
[5단계] 분석(Analysis) API 구현
https://www.notion.so/5-1c2caf5650aa809ba62ce9488ca62df1
[6단계] Django Signal을 이용한 알림 구현
https://www.notion.so/6-1c2caf5650aa80f3b565e5a4f6882876
[7단계] AWS Cloud Service 를 이용해서 배포
https://www.notion.so/7-1c2caf5650aa806ba040f5af5cf08ce4

poetry init

라이브러리 제거
poetry remove 라이브러리 이름

[tool.poetry.dependencies] 에는 배포 환경의 라이브러리를 설치
poetry add 라이브러리 이름

[tool.poetry.group.dev.dependencies] 에 개발환경의 라이브러리 설치
poetry add -G dev 라이브러리 이름

팀원이 해야할 일

poetry가 생성한 pyproject.toml에 작성된 dependencies목록을 기반으로 라이브러리 설치
poetry install --no-root
가상환경 없으면 가상환경을 자동생성함. 기본설정 : 전역위치에 가상화경 생성
혹은 가상환경을 미리 만든 상태에선 가상환경에 라이브러리를 설치

전역 가상환경 위치 확인
poetry env info --path

전역 가상환경 제거
poetry env remove python

가상환경 생성
python3 -m venv .venv

설정 파일 생성
django-admin startproject config .

앱 만들기
python3 manage.py startapp 앱이름

postgresql db 설치
brew install postgresql

PostgreSQL 서버 실행
brew services start postgresql

실행 확인
brew services

PostgreSQL 설치시 자동으로 생성되는 데이터베이스인 postgres에 접속
psql postgres

유저 확인
본인의 맥 유저 이름 혹은 postgres라는 유저가 있어야 정상
\du

새로운 유저를 생성
CREATE USER 유저이름

비밀번호 설정
ALTER USER root WITH PASSWORD '비밀번호';

권한 설정
ALTER USER root WITH SUPERUSER;

유저 다시 확인
\du

db 생성
CREATE DATABASE 데이터베이스이름;

db 목록 확인
\l


새로 생성된 유저 혹은 기본 유저를 활용하여 생성된 데이터베이스로 접속
psql 데이터베이스 이름
또는
psql -U 유저이름 -d 데이터베이스이름 -W
(W옵션은 비밀번호를 입력하여 접속하는 것 입니다. 필수는 아님)

테이블 내역을 조회
\dt

PostgreSQL을 Django에서 사용하려면 필요한 psycopg 설치
poetry add psycopg2-binary

ln -sf dev.py settings.py
ln -sf prod.py settings.py

ln -sf urls_dev.py urls.py
ln -sf urls_prod.py urls.py


bank db에 bankcode 데이터 넣기

bank db 접속
psql bank

db.txt에 있는 테이블 새성 쿼리 입력
INSERT INTO bank_code (code, name) VALUES
('000', '알수없음'),
('001', '한국은행'),
('002', '산업은행'),
...

깃 플로우
https://legend-palm-1f1.notion.site/Git-Flow-14acaf5650aa800387a7c43e334cc72e
https://legend-palm-1f1.notion.site/Git-Flow-14acaf5650aa80f2a4a9efa455e54f9b

맥에서 홈브루로 깃 플로우 설치
brew install git-flow-avh

깃 플로우 초기화
git flow init

Branch name for production releases?
→ 기본값은 master 이지만 main 으로 하는것 추천

Branch name for "next release" development?
→ develop (기본값)

나머지 엔터


# Feature 브랜치

생성: 새로운 기능을 개발할 때 사용
git flow feature start <기능이름>

완료: 기능 개발을 마치고 develop 브랜치로 병합
git flow feature finish <기능이름>

# Release 브랜치

생성: 배포 준비를 할 때 사용
git flow release start <버전번호>

완료: 릴리즈 완료 후 master와 develop에 병합
git flow release finish <버전번호>

# Hotfix 브랜치

생성: 긴급한 버그 수정이 필요할 때 사용
git flow hotfix start <버그이름>

완료: 수정 완료 후 master와 develop에 병합
git flow hotfix finish <버그이름>


## . Git Flow 전체 흐름

1. 팀 리더가 new project 생성하고 초기 세팅을 진행
2. 팀 리더가 github repository에 올리기
3. 나머지 팀원들은 repository에 올라 온 project를 클론받아 로컬에 가져옴
4. 전 팀원 `git flow init` (초기화) 해줌
    - 초기화 시 `Branch name for production releases?`질문에
    → 기본 값은 `master` 이지만 `main` 으로 설정하시는 것을 추천..
5. 모든 팀원 로컬 환경에서 `git branch` 명령어로 존재하는 브랜치를 확인해보면 처음에는 `main` 브랜치 뿐만 있었지만 초기화 이후  `develop` 브랜치가 로컬에 생겨있음을 확인가능.
6. 각자 맡은 기능 개발을 위해 `git flow feature start 기능이름` 명령어로 feature 브랜치를 생성
→ `git branch` 명령어로 확인해보면 `feature/기능이름` 브랜치가 생성되어있음.
7. 생성된 feature 브랜치에서 기능 개발 작업합니다.
8. 작업 완료 후 feature 브랜치를 원격 저장소에 push 해서 PR 올립니다.
9. PR 타이틀, 설명 등 작성 후 리뷰어 팀원들 등록합니다.
10. PR 승인 되면 Squash and Merge 버튼을 통해 압축 된 하나의 커밋으로 develop에 머지합니다.
11. 그리고 로컬 환경에서 `develop` 브랜치로 checkout 하고, 기능 개발시에 사용했던 기존의  feature 브랜치는 삭제해줍니다.
12. 개발된 기능이 업데이트 된 원격 저장소의 `develop` 브랜치를 `pull` 합니다.
    - `git pull origin develop` 명령어 사용하기
13. (( 7~13번 무한 반복 ))
14. 각 팀원들이 기능 개발을 모두 완료했다면 배포할 준비를 해야합니다. 팀장이 배포 관련 설정을 모두 완료하고 `develop` 브랜치에 머지합니다.
15. `main` 브랜치와 `develop` 브랜치를 compare & PR 한 후 `merge` 합니다.
16. `main` 브랜치를 EC2 에서 클론받아 배포를 진행합니다.


.gitignore 시크릿 폴더 업로드 제한
.config_secret/

시크릿 폴더 생성
.config_secret

시크릿 폴더에 secret.json 생성

secret.json에 입력
{
  "DJANGO_SECRET_KEY" : "django-insecure-9u=$gmlz$b8h2^d9%3x871ti9pcile_q19lif*#yw(q@#=nb!8",
  "email": {
    "user": "이메일",
    "password": "비밀번호"
  },
  "DB": {
  "ENGINE": "django.db.backends.postgresql",
  "NAME": "bank",
  "USER": "root",
  "PASSWORD": "1234",
  "HOST": "localhost",
  "PORT": "5432"
  }
}

시크릿 파일 읽어 오기 위해 settings.py에 설정

with open(BASE_DIR / '.config_secret' / 'secret.json') as f:
    config_secret_str = f.read()

SECRET = json.loads(config_secret_str)  # json 형태를 딕셔너리 형태로 바꿈

# Email
# from django.core.mail.backends.smtp import EmailBackend
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.naver.com' # 네이버 환결설정에서 볼 수 있음.
EMAIL_USE_TLS = True  # 보안연결
EMAIL_PORT = 587  # 네이버 메일 환경설정에서 확인 가능
EMAIL_HOST_USER = SECRET["email"]["user"]
EMAIL_HOST_PASSWORD =  SECRET["email"]["password"]

# .config_secret 폴더 만들고
# 폴더에 secret.json 만들고
# .gitignore에 추가한 후 관리
# print(SECRET['DB']['HOST'])
# print(SECRET['DB2']['HOST'])
# 이렇게 쓸 수도있고 dotenv를 통해 관리할 수도 있음

LOGIN_URL = '/login/'
LOGOUT_REDIRECT_URL = '/login/'
# LOGOUT_REDIRECT_URL = '/'



simplejwt 시작
https://django-rest-framework-simplejwt.readthedocs.io/en/latest/getting_started.html

simplejwt 설치
poetry add djangorestframework-simplejwt

# config/settings.py

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        ...
        'rest_framework_simplejwt.authentication.JWTAuthentication',
        ...
    ]
}
INSTALLED_APPS = [
    ...
    'rest_framework_simplejwt',
    ...
]

# config/urls.py

urlpatterns = [
    ...
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('api/token/verify/', TokenVerifyView.as_view(), name='token_verify'),
    ...
]

simplejwt 세팅
https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html#


simplejwt 커스터 마이징
https://django-rest-framework-simplejwt.readthedocs.io/en/latest/customizing_token_claims.html

# utils/jwt_serializers.py

from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework_simplejwt.views import TokenObtainPairView

class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)

        # Add custom claims
        token['user_name'] = user.username  # 토큰에 유저 이름을 함께 담아서 보냄

        return token

# config/settings.py
# JWT 설정
SIMPLE_JWT = {
  # It will work instead of the default serializer(TokenObtainPairSerializer).
  "TOKEN_OBTAIN_SERIALIZER": "utils.jwt_serializers.MyTokenObtainPairSerializer",
  # ...
}

토큰 정보 보는 법
https://jwt.io/

토큰 만료시간 수정
# JWT 설정
SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=1),
    # It will work instead of the default serializer(TokenObtainPairSerializer).
    "TOKEN_OBTAIN_SERIALIZER": "utils.jwt_serializers.MyTokenObtainPairSerializer",
    # ...
}

poetry add -G dev django-extensions
poetry add -G dev ipython

poetry.lock 업데이트
poetry lock


개발환경으로 가상환경에 라이브러리 설치
poetry install --with dev --no-root

로그아웃 구현
INSTALLED_APPS = [
    ...
    'rest_framework_simplejwt.token_blacklist',
]

# JWT 설정
SIMPLE_JWT = {
    "BLACKLIST_AFTER_ROTATION": True,
    "ROTATE_REFRESH_TOKENS": True,
}

python manage.py migrate

--------------------
이메일 보내는 기능 문제
--------------------

DEBUG=False일 때 이메일 보내는 기능에 문제생긴다면.

from django.core.mail import send_mail
send_mail 함수를 사용할 때 문제가 생긴다면

try:
    send_mail(subject, message, settings.EMAIL_HOST_USER, to_email)
except Exception as e:
    print(repr(e))
    raise

이렇게 해서 실패 했을 때 원인을 오류 코드로 파악한다.

원인은
SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self-signed certificate in certificate chain (_ssl.c:1018)')
인증서를 찾지 못해서 오류가 났다는 말인데

파이썬 라이브러리 certifi 설치 후
인증서를 강제로 인식 가능하게 certifi로 설정하면 어떠한 경우에도 사용가능하다.
인증서 경로를 인식못하든 인증서가 실제로 존재하지 않든 인식.

터미널에 입력해서 일시적으로 해결하는 방법
export SSL_CERT_FILE=$(python -m certifi)

해결방법1
터미널에 영구 적용

vim ~/.zshrc
맨 아랫 줄에 추가
export SSL_CERT_FILE=$(python -m certifi)

해결방법2
가상환경이 활성화 될때마다 인증서 경로를 자동 지정할 수 있도록 설정한다.

activate스크립트 수정
vim .venv/bin/activate
맨 아랫줄에 추가
export SSL_CERT_FILE=$(python -m certifi)

해결방법3 (가장 추천)
프로젝트가 인증서 경로를 인식할 수 있도록 장고 프로젝트에 설정

certifi라이브러리 없으면 설치 후

settings.py 최상단에 설정

import os
import certifi
os.environ['SSL_CERT_FILE'] = certifi.where()

-----------
  배포하기
-----------
https://www.notion.so/7-1c2caf5650aa806ba040f5af5cf08ce4

EC2, S3, IAM 생성

.env 작성하기
값이랑 주석이랑 같은 줄에 있으면 주석도 같이 값으로 인식
공백도 있으면 안됨
# IAM 키 (다운받은 csv 파일에서 확인)
S3_ACCESS_KEY=생성한 액세스 키
S3_SECRET_ACCESS_KEY=생성한 비밀 액세스 키

# S3 버킷 설정
S3_STORAGE_BUCKET_NAME=본인 버킷 이름
S3_REGION_NAME=ap-northeast-2

django-storages, boto3 설치
poetry add django-storages boto3

- `django-storages`: static, media 같은 파일을 저장소와 연결해주는 라이브러리
- `boto3`: AWS 에 python을 이용해서 엑세스할 수 있도록 해주는 라이브러리

# settings.py에 추가

# INSTALLED_APPS에 storages 추가
INSTALLED_APPS = [
  	...
    "storages",
]

# Static, Media URL 수정
STATIC_URL = f'https://{os.getenv("S3_STORAGE_BUCKET_NAME", "django-mini-project")}.s3.amazonaws.com/static/'
MEDIA_URL = f'https://{os.getenv("S3_STORAGE_BUCKET_NAME", "django-mini-project")}.s3.amazonaws.com/media/'

# STORAGES 작성
STORAGES = {
    "default": {
        "BACKEND": "storages.backends.s3.S3Storage",
        "OPTIONS": {
            "access_key": os.getenv("S3_ACCESS_KEY", ""),
            "secret_key": os.getenv("S3_SECRET_ACCESS_KEY", ""),
            "bucket_name": os.getenv("S3_STORAGE_BUCKET_NAME", ""),
            "region_name": os.getenv("S3_REGION_NAME", ""),
            "location": "media",
            "default_acl": "public-read",
        },
    },
    "staticfiles": {
        "BACKEND": "storages.backends.s3.S3Storage",
        "OPTIONS": {
            "access_key": os.getenv("S3_ACCESS_KEY", ""),
            "secret_key": os.getenv("S3_SECRET_ACCESS_KEY", ""),
            "bucket_name": os.getenv("S3_STORAGE_BUCKET_NAME", ""),
            "region_name": os.getenv("S3_REGION_NAME", ""),
            "custom_domain": f'{os.getenv("S3_STORAGE_BUCKET_NAME", "")}.s3.amazonaws.com',
            "location": "static",
            "default_acl": "public-read",
        },
    },
}

--------------------------
# S3에 static 파일 업로드 하기
--------------------------

python-dotenv 설치
poetry add python-dotenv

settings.py에 설정
from dotenv import load_dotenv
load_dotenv(BASE_DIR / '.env')  # .env 파일 로드

# S3에 static 파일 업로드
python3 manage.py collectstatic

--------------
RDS 생성 및 설정
--------------

RDS생성

.env에 DATABASES 정보 입력

settings.py(prod.py)에 설정
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv("DB_NAME"),              # 생성한 DB 이름
        'USER': os.getenv("DB_USER"),              # PostgreSQL 사용자
        'PASSWORD': os.getenv("DB_PASSWORD"),      # 비밀번호
        'HOST': os.getenv("DB_HOST"),              # 로컬에서 실행 중이므로 localhost
        'PORT': os.getenv("DB_PORT", "5432"),      # RDS 엔드포인트
    }
}

ec2 접속
ssh -i 키/페어/저장/위치/mp-key.pem ubuntu@EC2_PUBLIC_IP

--------------------------
# Docker 세팅
--------------------------

작성한 Dockerfile을 통해 이미지를 빌드
docker build -t django .

빌드된 Docker 이미지를 통해 컨테이너 실행
docker run -p 8000:8000 --env-file .env django

Dockerfile 생성
# 베이스 이미지 (본인 프로젝트에 맞는 버전 기입)
FROM python:3.12-slim

ENV PYTHONUNBUFFERED 1
ENV PYTHONDONTWRITEBYTECODE 1

# 종속성 파일 복사
COPY ./poetry.lock /mini_project/
COPY ./pyproject.toml /mini_project/

# 작업 디렉토리 설정
WORKDIR /mini_project

# 종속성 설치
RUN pip3 install poetry
RUN poetry config virtualenvs.create false
RUN poetry install
RUN poetry add gunicorn

# 애플리케이션 코드 복사
COPY ./app /mini_project/app
WORKDIR /mini_project/app


# 소켓 파일 생성 디렉토리 권한 설정
RUN mkdir -p /mini_project && chmod -R 755 /mini_project

# Gunicorn을 사용하여 애플리케이션 실행
CMD ["gunicorn", "config.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "2"]

쉘 스크립트 작성

scripts/run.sh 생성
mkdir -p scripts
touch scripts/run.sh

도커 빌드
docker build -t django .

빌드된 Docker 이미지를 통해 컨테이너 실행
docker run -p 8000:8000 --env-file .env django

실행중인 도커 확인
docker ps

컨테이너 중지
docker stop <컨테이너ID 또는 이름>



- 🔖 **mission_1 : 작성 내용 GitHub 등록**
    1. 새로 작성한 `Dockerfile`, `run.sh` 파일을 제외한 나머지 파일들을 업로드합니다.

        ```bash
        # Django 프로젝트 코드를 app 폴더로 합친경우
        git add app

        # 커밋 메시지 작성
        git commit -m "AWS 연결 완료"

        # 업로드
        git push origin <개발 브랜치>
        ```

    2. 배포용 브랜치를 생성합니다. (선택)

        ```bash
        # 브랜치 생성
        git branch release

        # 브랜치 변경
        git switch release
        ```

    3. 해당 브랜치에 나머지 파일(`Dockerfile`, `run.sh` 등) 업로드합니다.

        > 따로 배포용 브랜치를 만들지 않는다면 main 또는 dev브랜치에 업로드 하시면 됩니다.
        >

        ```bash
        # 업로드할 파일 추가
        git add .

        # 커밋 메시지 작성
        git commit -m "Docker 작성 완료"

        # 업로드
        git push origin release
        ```

- 🔖 **mission_2 : EC2 인스턴스로 가져오기**
    - Git 설치

        ```bash
        # APT 저장소 최신화
        sudo apt-get update

        # Git 설치
        sudo apt-get install git
        ```

    1. 인스턴스에 접속해줍니다. (접속 방법은 상단 AWS EC2 부분을 참고하시면 됩니다!)
    2. GitHub 리포지토리의 `release` 브랜치를 클론(clone) 합니다.

        ```bash
        git clone -b release <repository url>
        ```

        - `-b release`: `release` 브랜치 내용을 클론합니다.
- 🔖 **mission_3 : `.env` 파일 작성**
    1. 폴더 이동 및 `.env` 파일을 생성합니다.

        ```bash
        # 클론 받은 폴더로 이동합니다.
        cd mini_project

        # .env 파일 생성
        vim .env
        ```

    2. .env 파일 내용 복사해서 넣기



- 🔖 **mission_4 : Docker 빌드 및 실행**

    > 설치를 제외한 1~3번 까지는 로컬에서 진행한 방식과 동일합니다.
    >
    - **Docker 설치**

        > 만약 이전에 Docker를 설치했다가 실패 하셨다면 먼저 제거 후 진행해주시기 바랍니다.
        `for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done`
        >

        ```bash
        # 필요한 프로그램 설치 및 Docker official GPG key 등록
        sudo apt-get update
        sudo apt-get install ca-certificates curl
        sudo install -m 0755 -d /etc/apt/keyrings
        sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
        sudo chmod a+r /etc/apt/keyrings/docker.asc

        # APT 소스 파일에 도커 저장소 연결 (전체를 한번에 입력해야 합니다.)
        echo \
          "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
          $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
          sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

        # 연결 후 저장소 새로고침
        sudo apt-get update

        # Docker 설치
        sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

        # 설치 확인
        docker --version
        ```

    - **docker 그룹에 사용자 추가하는 방법**
        1. 명령어를 입력해 docker 그룹에 사용자를 추가합니다.

            ```bash
            # docker gorupd 에 user 추가
            sudo usermod -aG docker $USER

            # group에 추가 되었는지 확인
            groups $USER
            # 결과> ubuntu : ubuntu adm cdrom sudo dip lxd docker
            ```

            - `$USER`: 현재 로그인한 사용자의 이름을 자동으로 참조합니다.
            - `usermod -aG`: 사용자를 지정된 그룹에 추가합니다.
        2. 종료 후 재접속하거나 명령어를 통해 변경 사항을 즉시 적용합니다.

            ```bash
            newgrp docker
            ```

            - 만약 docker 명령어가 여전히 sudo 없이 안된다면 종료후 재접속 해주시면 됩니다.
    1. Docker 빌드를 위해 `Dockerfile`이 있는 위치로 이동합니다. (프로젝트 루트 폴더)
    2. Docker 빌드를 진행해 이미지를 생성합니다.
    3. 생성한 이미지를 사용해 Docker 컨테이너를 실행합니다.
    4. 테스트를 위해 보안그룹 규칙에 8000포트를 추가합니다.
        - 작업중인 EC2의 보안그룹으로 이동해줍니다.

            ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/00feaf78-d356-41ee-90f9-616e7f73fd77/0445c283-0ff0-472f-bc43-394b343182fc/image.png)

        - 인바운드 규칙을 편집을 클릭합니다.

            ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/00feaf78-d356-41ee-90f9-616e7f73fd77/eafd1106-fb90-4839-bdca-23e14a5f6d18/image.png)

        - 8000포트를 추가하고 저장합니다.

            ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/00feaf78-d356-41ee-90f9-616e7f73fd77/7a529c27-042c-496c-9b3c-d8c3c79f6b37/image.png)

    5. API로 접근해서 적용이 잘 되었는지 확인합니다.
        - host 부분은 EC2 인스턴스의 퍼블릭 아이피로 사용합니다.

            ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/00feaf78-d356-41ee-90f9-616e7f73fd77/5ff341f1-a93f-44e6-85ac-ca4b118950be/image.png)

        - 브라우저 또는 Postman을 활용해서 API에 접근이 되는지 테스트합니다.

            ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/00feaf78-d356-41ee-90f9-616e7f73fd77/156a9707-0dd8-4c97-a066-426cf698d51e/image.png)

- 🔖 **mission_5 : 백그라운드 모드로 Docker 실행**

    ```bash
    sudo docker run -p 8000:8000 -d --env-file .env django
    ```

    - `-d` 옵션을 사용해 Docker를 백그라운드 모드로 실행할 수 있습니다.